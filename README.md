[1.  Платформа Java EE. Спецификации и их реализации.](#1)

[2.  Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры.](#2)

[3.  Управление жизненным циклом компонентов. Дескрипторы развёртывания.](#3)

[4.  Java EE API. Виды компонентов. Профили платформы Java EE.](#4)

[5.  Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full.](#5)

[6.  Работа с электронной почтой в Java EE. JavaMail API.](#6)

[7.  JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans.](#7)

[8.  Понятие транзакции. Управление транзакциями в Java EE. JTA.](#8)

[9.  Веб-сервисы. Технологии JAX-RS и JAX-WS.](#9)

[10.  Платформа Spring. Сходства и отличия с Java EE.](#10)

[14.  React JS. Архитектура и основные принципы разработки приложений.](#14)

[15.  Компоненты React. State & props. "Умные" и "глупые" компоненты.](#15)

[16.  Разметка страниц в React-приложениях. JSX.](#16)

[17.  Навигация в React-приложениях. ReactRouter.](#17)

[18.  Управление состоянием интерфейса. Redux.](#18)

[19.  Angular: архитектура и основные принципы разработки приложений.](#19)

[20.  Angular: модули, компоненты, сервисы и DI.](#20)

[21.  Angular: шаблоны страниц, жизненный цикл компонентов, подключение CSS.](#21)

[22.  Angular: клиент-серверное взаимодействие, создание, отправка и валидация данных форм.](#22)


## 1
_Платформа Java EE. Спецификации и их реализации._

Набор спецификаций - см. 4 вопрос.  
Реализации: GlassFish, WildFly, TomEE, IBM WebSphere и т.д.

## 2
_Принципы IoC, CDI и Location Transpanency. Компоненты и контейнеры._

_Inversion of Control_: объекты создает не программист (используя `new`), а контейнер IoC. Применяется далеко не ко всем объектам в приложении, а только к управляемым
(в Spring это классы с аннотациями `@Component`, `@Service` и т.д., в EJB — бобы `@Stateless`, `@Stateful`, `@MessageDriven`).

Контейнер не только создает объекты, но полностью управляет их жизненным циклом, вызывая на определенных этапах callback методы.

_Dependency injection_:

Вместо построения зависимостей в компоненте, где они нужны:

```java
public class Something {
  private Dependency dependency = new Dependency()
}
```

Мы принимаем их извне, что избавляет компонент от необходимости управлять ими:

```java
public class Something {
  private Dependency dependency;

  public Something (Dependency dependency) {
    this.dependency = dependency;
  }
}  
```

Чтобы нам не пришлость вручную собирать все зависимости для создания компонентов,
контейнер IoC предоставляет возможность внедрения инстанций в поля, помеченные специальной аннотацией:

```java
public class SomethingDI {
  @Autowired private Dependency dependency; // Spring
  @EJB private EjbDependency ejbDependency; // EJB
}
```

## 3
_Управление жизненным циклом компонентов. Дескрипторы развёртывания._

Web-контейнер реализует такие службы, как управление жизненным циклом компонентов и набором компонентов как ресурсом, распараллеливание независимых работ, выполнение удаленных обращений к компонентам, поддержка защищенности с помощью проверки прав компонентов и пользователей на выполнение различных операций.

Дескриптор развёртывания — конфигурационный файл артефакта, который будет развёрнут в контейнере сервлетов. В спецификации Java Platform, Enterprise Edition дескриптор развёртывания описывает то, как компонент, модуль или приложение (такое, как веб-приложение или приложение предприятия) должно быть развёрнуто[1].

Этот конфигурационный файл указывает параметры развёртывания для модуля или приложения с определёнными настройками, параметры безопасности и описывает конкретные требования к конфигурации. Для синтаксиса файлов дескриптора развёртывания используется язык XML.


## 4
_Java EE API(Спецификации). Виды компонентов. Профили платформы Java EE._
![javaProfiles](https://github.com/SunnyCapt/__pip__/raw/master/l4/javaProfiles.png)
JAXB - https://www.codeflow.site/ru/article/jaxb  
JACC - спецификация, определяющая взаимодествие между сервером приложений Java EE и сервисом авторизации.  
JCA - https://habr.com/ru/post/251131/

## 5
_Компоненты EJB. Stateless & Stateful Session Beans. EJB Lite и EJB Full._

EJB (Enterprise Java Bean) — спецификация для разработки серверных компонентов, реализующих бизнес-логику.

Компоненты — бобы, которые делятся на _session beans_ (заседательные бобы) и _message driven beans_ (бобы, движимые посланиями).

_Session beans_ в свою очередь делятся на:
* _stateful_: у каждого клиента своя инстанция, в которой хранится его состояние
* _stateless_: одна и та же инстанция обеспечивает запросы нескольких клиентов => лучше масштабируются, но не могут сохранять состояние между последовательными обращениями клиента
* _singleton_: одна инстанция на все приложение => общее для всех клиентов состояние

_Message driven beans_ выполняют метод в ответ на получение сообщения из определенной очереди JMS.

Аннотация `@EJB` предоставляет клиентам не сам объект, а прокси, через который можно получить доступ к методам бизнес-интерфейсов. Может осуществляться доступ как к локальным, так и удаленным (в другой JVM) объектам.

## 6
_Работа с электронной почтой в Java EE. JavaMail API._
Свободно распространяемая библиотека _JavaMail_ предназначена для подключения к почтовым серверам с целью получения и отправки электронной почты с использованием протоколов _SMTP_, _POP3_ и _IMAP_. Библиотека позволяет отправлять сообщения с вложениями и удалять их на почтовом сервере.

*   SMTP (Simple Mail Transfer Protocol простой протокол передачи почты) - это широко используемый сетевой протокол для передачи электронной почты в сетях TCP/IP. Электронные почтовые серверы используют протокол _SMTP_ для отправки и получения почтовых сообщений. Клиентские почтовые приложения обычно используют _SMTP_ только для отправки сообщений на почтовый сервер и для ретрансляции с использованием порта 25 (465 для SSL). Т.е. протокол _SMTP_ применяют для передачи исходящей почты.
*   IMAP (Internet Message Access Protocol) — протокол прикладного уровня для доступа к электронной почте. Протокол _IMAP_ предоставляет пользователю широкие возможности для работы с почтовыми ящиками, расположенными на удаленном сервере. Почтовая программа, использующая данный протокол, получает доступ к хранилищу корреспонденции на сервере так, как будто эта корреспонденция расположена на компьютере получателя. Электронными письмами можно управлять с компьютера пользователя без пересылки файлов по сети. Протокол _IMAP_ использует транспортный протокол TCP и прослушивает порт 143.
*   POP3 (Post Office Protocol Version 3 протокол почтового отделения 3-ей версии) - это стандартный сетевой протокол прикладного уровня, используемый клиентами электронной почты для получения почты с удаленного сервера по TCP/IP-соединению. Протокол _POP3_ поддерживает простые требования «загрузи-и-удали» для доступа к удаленным почтовым ящикам. Сервер POP3 прослушивает порт 110.


## 7
_JMS. Реализация очередей сообщений. Способы доставки сообщений до клиента. Message-Driven Beans._

Java Message Service — стандарт для асинхронного распределенного взаимодействия программных компонентов (которые могут находиться на одном компьютере, в одной локальной сети, или быть связаны через Интернет) путем рассылки сообщений.

JMS поддерживает две модели коммуникации: _point-to-point_ и _publish-subcribe (pubsub)_.

В _point-to-point_ сообщения от разных отправителей адресуются определенной очереди, к которой подключаются клиенты. При этом для каждого сообщения гарантируется, что оно будет доставлено одному и только одному клиенту.

В _pubsub_ сообщения адресуются определенному topic'у, на которые подписываются клиенты. Каждое сообщение может быть получено несколькими клиентами или не получено вообще, если подписчиков на момент доставки не было.

Существует несколько реализаций JMS провайдеров (RabbitMQ, Open Message Queue, ...)

## 8
_Понятие транзакции. Управление транзакциями в Java EE. JTA._

Транзакция — группа последовательных операций, представляет собой логическую единицу работы с данными. Транзация либо выполняется успешно и целиком, соблюдая целостность данных, либо не производит никакого эффекта на данные.

_Java Transaction API_ позволяет выполнять распределенные транзакции, т.е. транзакции, читающие и обновляющие данные на разных сетевых ресурсах (которыми могут быть различные серверы баз данных, JMS).

JTA предоставляет высокоуровневый интерфейс для управления транзакиями (begin, commit, rollback), избавляя от необходимости работы с каждым ресурсом по-своему (интерфейс транзакций в JDBC, например, немного отличается от интерфейса JMS).

Транзация координируется transaction manager'ом. Взаимодействие с ресурсами осуществляется через resource manager'ы.

Транзакции могут быть объявлены:
* декларативно — аннотацией `@Transactional` на отдельном методе или всем классе, при этом rollback происходит при необработанном `RuntimeException`
* программно — вызывая `begin`, `rollback`, `commit` у [`UserTransaction`](https://docs.oracle.com/javaee/6/api/javax/transaction/UserTransaction.html)


## 9.
_Веб-сервисы. Технологии JAX-RS и JAX-WS._
[JAX-WS](http://en.wikipedia.org/wiki/Java_API_for_XML_Web_Services) -is Java API для XML-Based Web Services-стандартный способ разработки Web-сервисов в нотации [SOAP](http://en.wikipedia.org/wiki/SOAP) (Simple Object Access Protocol).

Вызов веб-служб осуществляется с помощью удаленных вызовов процедур. Для обмена информацией между клиентом и веб-сервисом используется протокол SOAP. Обмен сообщениями между клиентом и сервером осуществляется через [XML](http://en.wikipedia.org/wiki/XML) - основанные SOAP сообщения.

Клиенты веб-службы JAX-WS нуждаются в файле [WSDL](http://en.wikipedia.org/wiki/Web_Services_Description_Language) для генерации исполняемого кода, который клиенты могут использовать для вызова веб-службы.

[JAX-RS](http://en.wikipedia.org/wiki/Java_API_for_RESTful_Web_Services) -Java API для веб-служб RESTful. RESTful веб-службы представлены как ресурсы и могут быть идентифицированы с помощью унифицированных идентификаторов ресурсов ( [URI](http://en.wikipedia.org/wiki/Uniform_resource_identifier) ). Удаленный вызов процедуры в этом случае представляется [HTTP](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)\-запросом и необходимые данные передаются в качестве параметров запроса. Веб-сервисы RESTful-более гибкие, могут использовать несколько различных [MIME](http://en.wikipedia.org/wiki/Internet_media_type) - типов. Обычно используется для обмена данными XML или [JSON](http://en.wikipedia.org/wiki/JSON) (обозначение объекта JavaScript)...

## 10
_Платформа Spring. Сходства и отличия с Java EE._
#### Spring DI (Dependency Injection) vs CDI (Context Dependency Injection)

Даже из названия понятно, что ядра в обоих стеках совершенно идентичны по характеристикам. Так и есть. Фактически в Java EE стеке изначально и использовался спринговый DI. Но после того как его включили прямо в Core, использовать его отдельно стало невозможно. Пришлось делать свой DI с аннотациями и программистками.

Получилось в общем-то неплохо, даже чуть-чуть лучше, на мой вкус. Но различия настолько незначительны, что ими можно пренебречь.

#### Spring Beans vs EJB (Enterprise Java Beans)

Тут, скажем, ситуация прямо противоположная. Spring beans — это просто обычные джава бины, которые можно куда-то заинжектить и ничего больше. EJB — достаточно мощная штуковина, в которую встроена поддержка распределенного (мультинодного) исполнения, включая распределенный сборщик мусора, аутентификацию, поддержку транзакций и черти что еще. Другой разговор, если все это вам не надо... Ну вы поняли :)

#### Spring MVC vs Java Server Faces (JSF)

Проблема этого сравнения в том, что SpringMVC в качестве темплейтного движка обычно используется Thymeleaf или в более современном варианте — какой-либо Front-end движок (React, Angular & etc). В то время, как JSF — полноценное GUI решение с поддержкой AJAX из коробки и даже SPA приложений с помощью дополнительных библиотек, включая такие гиперудобные и красивые, как PrimeFaces и IceFaces.

#### Spring Data vs JPA

Это единственный пункт, в котором Spring кроет как бык овцу стек Java EE. Spring Data — прекрасна, великолепна, быстра и удобна. Снимаю шляпу. Очень жаль, что аналога в Java EE стеке нет...

## 14
_React JS. Архитектура и основные принципы разработки приложений. arch_

![react](https://github.com/SunnyCapt/__pip__/raw/master/l4/react-arch.jpg)

Принципы разработки: есть компоненты, это функция/класс js. Они умеют генерить jsx элементы. Элементы могут быть вложенными друг в друга. Информация может передается между компонентами лишь от родителя к ребенку. Компоненты могут иметь состояние для хранения изменяемых данных. Реакт можно использовать как для написания всего приложения так и для реализации какой-то его части.

## 15
_Компоненты React. State & props. "Умные" и "глупые" компоненты._
глупые компоненты:

1.  не зависят от остальной части приложения, например Flux actions или stores
2.  часто содержатся в this.props.children
3.  получают данные и колбэки исключительно через props
4.  имеют свой css файл
5.  изредка имеют свой state
6.  могут использовать другие глупые компоненты
7.  примеры: Page, Sidebar, Story, UserInfo, List


умные компоненты:

1.  оборачивает один или несколько глупых или умных компонентов
2.  хранит состояние стора и пробрасывает его как объекты в глупые компоненты
3.  вызывает Flux actions и обеспечивает ими глупые компоненты в виде колбэков
4.  никогда не имеют собственных стилей
5.  редко сами выдают DOM, используйте глупые компоненты для макета
6.  примеры: UserPage, FollowersSidebar, StoryContainer, FollowedUserList

Профит от такого подхода
1.  Лучшее разделение ответственности. Вы понимаете Ваше приложение и Ваш UI лучше, если пишете компоненты таким способом.
2.  Лучшая реюзабельность. Вы можете использовать один и тот же глупый компонент с абсолютно разными источниками состояния.
3.  Глупые компоненты — это фактически «палитра» Вашего приложения, Вы можете поместить их все на одну страницу и дать дизайнеру их настроить, на залезая в логику приложения. Вы можете запустить регрессивное тестирование на такой странице.
4.  Это заставляет Вас извлекать «компоненты макеты», такие как Sidebar, Page, ContextMenu и использовать this.props.children вместо дублирования одной и той же верстки в различных умных компонентах.

## 16
_Разметка страниц в React-приложениях. JSX._
Это JSX — расширение языка JavaScript. Мы рекомендуем использовать его, когда требуется объяснить React, как должен выглядеть UI. JSX напоминает язык шаблонов, наделённый силой JavaScript.

JSX производит «элементы» React. То, как элементы рендерятся в DOM, мы изучим в [следующей главе](/docs/rendering-elements.html), а ниже мы рассмотрим основы JSX, которые нужно знать начинающему.

React исходит из принципа, что логика рендеринга неразрывно связана с прочей логикой UI: с тем, как обрабатываются события, как состояние изменяется во времени и как данные готовятся к отображению.

React [можно использовать и без JSX](/docs/react-without-jsx.html), но большинство людей ценит его за наглядность при работе с UI, живущем в JavaScript-коде. Помимо этого, JSX помогает React делать сообщения об ошибках и предупреждениях понятнее.

## 17
_Навигация в React-приложениях. ReactRouter._
https://habr.com/ru/post/459434/

## 18
_Управление состоянием интерфейса. Redux._
https://tproger.ru/translations/redux-for-beginners/

## 19
_Angular: архитектура и основные принципы разработки приложений._
    ![arch](https://github.com/SunnyCapt/__pip__/raw/master/l4/arch.png)
    
    Для разработки нужно настроить сборочное окружение (на базе node.js и npm). Приложения состоят из модулей (NgModules). Модули обеспечивают контекст для компонентов (components). Из компонентов строятся представления (views). Компоненты взаимодействуют с сервисами (services) с помощью DI.
## 20
_Angular: модули, компоненты, сервисы и DI._

    https://webdraftt.com/tutorial/angular-modules
    
    https://webdraftt.com/tutorial/angular-components
    
    https://webdraftt.com/tutorial/angular-services
    
    https://webdraftt.com/tutorial/dependency-injection
    
    https://habr.com/ru/post/434380/
    
## 21
_Angular: шаблоны страниц, жизненный цикл компонентов, подключение CSS._

    https://webdraftt.com/tutorial/angular-templates
    
    https://webdraftt.com/tutorial/component-lifecycle
    
    https://metanit.com/web/angular2/2.4.php
    
## 22
_Angular: клиент-серверное взаимодействие, создание, отправка и валидация данных форм._

    https://webdraftt.com/tutorial/angular-http-client
    
    https://webdraftt.com/tutorial/angular-http-interceptor
    
    https://webdraftt.com/tutorial/angular-forms
    
    https://webdraftt.com/tutorial/angular-reactive-forms
    
    https://webdraftt.com/tutorial/forms-validation
